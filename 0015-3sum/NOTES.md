- 리스트보다 set의 주요연산이 더 효율적이긴 하지만 리스트를 set으로 만들 때 o(n)의 시간복잡도가 든다

리팩토링 정리

**로직의 단계를 나누고 단계별로 분리**

- 코드의 의도가 잘 드러나도록 한다.
- 이해하기 쉬워 고치기 쉬워진다. (이점)
- 자료구조 -> 알고리즘 -> 자료구조 -> 알고리즘 식으로 나눠본다. (자료구조 단위로 나눠보는 것도 좋은 방법 -> 어떤 자료구조가 필요한지, 더 효율적일지 고민해본다)

이를 토대로 해당 문제의 단계를 나눠보면,

1. 조건에 맞는 조합 구하기
   - 조건: 나머지 요소(= 두 요소의 합)가 두 요소보다 뒤에 있어야함 (요소의 중복 사용 방지)
   - 자료구조: 딕셔너리 (조건 확인을 위해 `{ v: i }` 형태 필요, o(1) 탐색 시간)
   - 알고리즘: 두 요소의 조합
2. 조합의 중복 제거
   - 자료구조: 셋
   - 알고리즘: 정렬

`after`

```py
def threesum(xs):
    # 1) 조건에 맞는 조합 구하기
    index = defaultdict(int)
    for i, v in enumerate(xs): # o(n)
        index[v] = i

    res = []
    for (i, j) in combinations(range(len(xs)), 2): #o(n^2)
        x, y, z = xs[i], xs[j], -(xs[i] + xs[j])
        if j < index[z]:
            res.append((x, y, z))

    # 2) 조합의 중복 제거
    return set([tuple(sorted(c)) for c in res])
```

이전 코드와 비교하여 좋은 점

- 로직의 단계와 의도가 분명히 드러난다 -> 이해하기 쉽다
  - 이전 코드는 hash가 무엇을 뜻하는지 알기 어렵다
  - 조합의 유효성을 확인하는 코드와 조합의 중복을 피하는 코드가 섞여있어 이해하기 어렵다
